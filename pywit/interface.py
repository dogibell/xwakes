import os
import subprocess
from pathlib import Path
from typing import Any, List, Sequence, Tuple, Union

import numpy as np
from IW2D import (Eps1FromResistivity, FlatIW2DInput, InputFileFreqParams,
                  InputFileWakeParams, IW2DLayer, IW2DResult,
                  Mu1FromSusceptibility, RoundIW2DInput,
                  iw2d_impedance, load_iw2d_result)
from joblib import Parallel, delayed
from numpy.typing import ArrayLike
from scipy.constants import speed_of_light
from scipy.interpolate import interp1d
from yaml import BaseLoader, load

from pywit.component import Component
from pywit.element import Element

# A dictionary mapping the datafile-prefixes (as used in IW2D) to (is_impedance, plane, (a, b, c, d))
# Where is impedance is True if the component in question is an impedance component, and False if it is a
# wake component, and a, b, c and d are the source and test exponents of the component
component_names = {'wlong': (False, 'z', (0, 0, 0, 0)),
                   'wxdip': (False, 'x', (1, 0, 0, 0)),
                   'wydip': (False, 'y', (0, 1, 0, 0)),
                   'wxqua': (False, 'x', (0, 0, 1, 0)),
                   'wyqua': (False, 'y', (0, 0, 0, 1)),
                   'wxcst': (False, 'x', (0, 0, 0, 0)),
                   'wycst': (False, 'y', (0, 0, 0, 0)),
                   'zlong': (True, 'z', (0, 0, 0, 0)),
                   'zxdip': (True, 'x', (1, 0, 0, 0)),
                   'zydip': (True, 'y', (0, 1, 0, 0)),
                   'zxqua': (True, 'x', (0, 0, 1, 0)),
                   'zyqua': (True, 'y', (0, 0, 0, 1)),
                   'zxcst': (True, 'x', (0, 0, 0, 0)),
                   'zycst': (True, 'y', (0, 0, 0, 0))}

# The parent directory of this file
IW2D_SETTINGS_PATH = Path.home().joinpath('pywit').joinpath('config').joinpath('iw2d_settings.yaml')


def get_component_name(is_impedance, plane, exponents):
    """
    Get the component name from is_impedance, plane and exponents (doing the
    reverse operation of the dictionary in component_names)
    :param is_impedance: True for impedance component, False for wake
    :param plane: plane ('x', 'y' or 'z')
    :param exponents: four integers corresponding to (source_x, source_y, test_x, test_y) aka (a, b, c, d)
    :return: str with component name (e.g. 'zydip' or 'wxqua')
    """
    comp_list = [comp_name for comp_name, v in component_names.items()
                 if v == (is_impedance, plane, exponents)]
    if len(comp_list) != 1:
        raise ValueError(f"({is_impedance},{plane},{exponents}) cannot be found in"
                         " the values of component_names dictionary")

    return comp_list[0]


def get_iw2d_config_value(key: str) -> Any:
    with open(IW2D_SETTINGS_PATH, 'r') as file:
        config = load(file, Loader=BaseLoader)

    return config[key]


def component_recipes_from_legacy_iw2d_files(directory: Union[str, Path],
                     common_string: str) -> List[Tuple[bool, str, Tuple[int, int, int, int], np.ndarray, np.ndarray]]:
    """
    Imports data on the format generated by the C++ executables of the IW2D library and prepares it for construction of Components and
    Elements in PyWIT
    :param directory: The directory where the .dat files are located. All .dat files must be in the root of this
    directory
    :param common_string: A string preceding ".dat" in the filenames of all files to be imported
    :return: A list of tuples, one for each imported file, on the form (is_impedance, plane, (a, b, c, d), x, y),
    where x and y are numpy arrays with , one for the frequency/time of the data file and one for the impedance/wake
    """
    # The tuples are iteratively appended to this array
    component_recipes = []

    # Keeps track of what combinations of (is_impedance, plane, exponents) have been imported to avoid duplicates
    seen_configs = []

    # A list of all of the filenames in the user-specified directory
    filenames = os.listdir(directory)
    for i, filename in enumerate(filenames):
        # If the string preceding ".dat" in the filename does not match common_string, or if the first 5 letters
        # of the filename are not recognized as a type of impedance/wake, the file is skipped
        if filename[-4 - len(common_string):-4] != common_string or filename[:5].lower() not in component_names:
            continue

        # The values of is_impedance, plane and exponents are deduced from the first 5 letters of the filename using
        # the component_names-dictionary
        is_impedance, plane, exponents = component_names[filename[:5].lower()]

        # Validates that the combination of (is_impedance, plane, exponents) is unique
        assert (is_impedance, plane, exponents) not in seen_configs, \
            f"The {'impedance' if is_impedance else 'wake'} files " \
            f"'{filename}' and '{filenames[seen_configs.index((is_impedance, plane, exponents))]}' " \
            f"both correspond to the {plane}-plane with exponents {exponents}."
        seen_configs.append((is_impedance, plane, exponents))

        # Loads the data from the file as a numpy array
        raw_data = np.loadtxt(f"{directory}/{filename}", delimiter=" ", skiprows=1)
        
        # Extracts the position/frequency column of the data array
        x = raw_data[:, 0]
        
        # Extracts the wake/impedances from the data array
        y = raw_data[:, 1] + (1j * raw_data[:, 2] if raw_data.shape[1] == 3 else 0)

        # Appends the constructed tuple to component_recipes
        component_recipes.append((is_impedance, plane, exponents, x, y))

    # Validates that at least one file in the directory matched the user-specified common_string
    assert component_recipes, f"No files in '{directory}' matched the common string '{common_string}'."
    return component_recipes


def component_recipes_from_iw2dresult(iw2d_result: IW2DResult) -> List[Tuple[bool, str, Tuple[int, int, int, int], np.ndarray, np.ndarray]]:
    """Prepare the data of an IW2DResult for construction of PyWIT Component objects

    :param directory: An IW2DResult
    :type directory: IW2DResult
    :return: A list of Component recipes, each being a tuple containing the following: 
    (is_impedance, plane, exponents, frequencies, impedance_values)
    :rtype: List[Tuple[bool, str, Tuple[int, int, int, int], np.ndarray, np.ndarray]]
    """

    frequencies = iw2d_result.data.index
    
    component_recipes = []
    
    for component_name in iw2d_result.data.columns:
        
        # Make sure we are reading an impedance.
        # At the time of writing, only impedances are implemented in the IW2D Python interface
        # In the future, the wake could possibly be read as well, but the implementation has to be
        # considered then.
        assert component_name.lower().startswith("z")
        
        component_metadata = iw2d_result.metadata[component_name]
        plane = component_metadata["Plane"]
        exponents = component_metadata["Exponents"]
        
        component_recipes.append(
            (True, plane, exponents, frequencies, iw2d_result.data[component_name])
        )
    
    return component_recipes

def create_component_from_data(is_impedance: bool, plane: str, exponents: Tuple[int, int, int, int],
                               x: np.ndarray, y: np.ndarray, relativistic_gamma: float) -> Component:
    """
    Creates a Component from a component recipe, e.g. as generated by import_data_iw2d
    :param is_impedance: a bool which is True if the component to be generated is an impedance component, and False
    if it is a wake component
    :param plane: the plane of the component
    :param exponents: the exponents of the component on the form (a, b, c, d)
    :param x: a 1D numpy-array containing frequencies [Hz] if is_impedance==True, else z values [m]
    :param y: a 1D numpy-array containing impedance values if is_impedance==True, else wake values
    :param relativistic_gamma: The relativistic gamma used in the computation of the data files. Necessary for
    converting the position-data of IW2D into time-data for PyWIT
    :return: A Component object as specified by the input
    """
    
    if not is_impedance:
        # Converts position-data to time-data using Lorentz factor
        x /= speed_of_light * np.sqrt(1 - (1 / relativistic_gamma ** 2))

    # Creates a callable impedance/wake function from the data array
    func = interp1d(x=x, y=y, kind='linear', assume_sorted=True, bounds_error=False, fill_value=(0., 0.))

    # Initializes and returns a component based on the parameters provided
    return Component(impedance=(func if is_impedance else None),
                     wake=(None if is_impedance else func),
                     plane=plane,
                     source_exponents=exponents[:2],
                     test_exponents=exponents[2:], )


def standard_layer(thickness: float, dc_resistivity: float, resistivity_relaxation_time: float, re_dielectric_constant: float,
                   magnetic_susceptibility: float, permeability_relaxation_frequency: float) -> IW2DLayer:
    return IW2DLayer(
        thickness=thickness,
        eps1=Eps1FromResistivity(
            dc_resistivity=dc_resistivity,
            resistivity_relaxation_time=resistivity_relaxation_time,
            re_dielectric_constant=re_dielectric_constant
        ),
        mu1=Mu1FromSusceptibility(
            magnetic_susceptibility=magnetic_susceptibility,
            permeability_relaxation_frequency=permeability_relaxation_frequency
        )
    )


def check_already_computed(iw2d_input: Union[FlatIW2DInput, RoundIW2DInput], additional_iw2d_params: Union[InputFileFreqParams, InputFileWakeParams],
                           name: str) -> Tuple[bool, str, Union[str, Path]]:
    """
    Checks if a simulation with inputs iw2d_input is already present in the hash database.
    :param iw2d_input: an iw2d input object
    :param name: the name of the object
    :return already_computed: boolean indicating if the iw2d_inputs have been already
    computed
    :return input_hash: string with the hash key corresponding to the inputs
    :return working_directory: the path to the directory where the files were put, which is built as
    `<first_two_characters_of_the_hash>/<next_two_characters>/<rest of the hash>
    """
    projects_path = Path(get_iw2d_config_value('project_directory'))

    # create the hash key
    input_hash = iw2d_input.input_file_hash(additional_iw2d_params)

    # we have three levels of directories: the first two are given by the first and second letters of the hash keys,
    # the third is given by the rest of the hash keys.
    directory_level_1 = projects_path.joinpath(input_hash[0:2])
    directory_level_2 = directory_level_1.joinpath(input_hash[2:4])
    working_directory = directory_level_2.joinpath(input_hash[4:])

    calculate_wake = isinstance(additional_iw2d_params, InputFileWakeParams)

    already_computed = True

    # check if the directories exist. If they do not exist we create
    if not os.path.exists(directory_level_1):
        already_computed = False
        os.mkdir(directory_level_1)

    if not os.path.exists(directory_level_2):
        already_computed = False
        os.mkdir(directory_level_2)

    if not os.path.exists(working_directory):
        already_computed = False
        os.mkdir(working_directory)

    components = []
    if not calculate_wake:
        for component in component_names.keys():
            # the ycst component is only given in the case of a flat chamber and the x component is never given
            if component.startswith('z') and 'cst' not in component:
                components.append(component)
            if isinstance(iw2d_input, FlatIW2DInput):
                components.append('zycst')
    else:
        for component in component_names.keys():
            # if the wake is computed, all keys from component_names dict are added, except the constant impedance/wake
            # in first instance. If the simulation is a flat chamber, we add the vertical constant impedance/wake
            if 'cst' not in component:
                components.append(component)
            if isinstance(iw2d_input, FlatIW2DInput):
                components.append('wycst')
                components.append('zycst')

    # The simulation seems to have been already computed, but we check if all the components of the impedance
    # wake have been computed. If not, the computation will be relaunched
    if already_computed:
        # this list also includes the input file but it doesn't matter
        computed_components = [name[0:5].lower() for name in os.listdir(working_directory)]

        for component in components:
            if component not in computed_components:
                already_computed = False
                break

    if already_computed:
        print(f"The computation of '{name}' has already been performed with the exact given parameters. "
              f"These results will be used to generate the element.")

    return already_computed, input_hash, working_directory


def check_valid_hash_chunk(hash_chunk: str, length: int):
    """
    Checks that the hash_chunk string can be the part of an hash key of given length. This means that hash_chunk must
    have the right length and it must be a hexadecimal string
    :param hash_chunk: the string to be checked
    :param length: the length which the hash chunk should have
    :return: True if hash_chunk is valid, False otherwise
    """
    if len(hash_chunk) != length:
        return False

    # check if the hash is an hexadecimal string
    try:
        int(hash_chunk, 16)
        return True
    except ValueError:
        return False


def check_valid_working_directory(working_directory: Path):
    """
    Checks if working_directory is valid. To be valid working directory must be of the form
    `<project_directory>/hash[0:2]/hash[2:4]/hash[4:]`
    :param working_directory: the path to the directory to be checked
    :return: True if the working_directory is valid, False otherwise
    """
    projects_path = Path(get_iw2d_config_value('project_directory'))

    if working_directory.parent.parent.parent != projects_path:
        raise ValueError(f"The working directory must be located inside {projects_path}")

    return (check_valid_hash_chunk(working_directory.parent.parent.name, 2) and
            check_valid_hash_chunk(working_directory.parent.name, 2) and
            check_valid_hash_chunk(working_directory.name, 60))


def add_iw2d_input_to_database(iw2d_input: Union[FlatIW2DInput, RoundIW2DInput], additional_iw2d_params: Union[InputFileFreqParams, InputFileWakeParams], input_hash: str,
                               working_directory: Union[str, Path]):
    """
    Add the iw2d input to the repository containing the simulations
    :param iw2d_input: the input object of the IW2D simulation
    :param input_hash: the hash key corresponding to the input
    :param working_directory: the directory where to put the iw2d input file
    """
    if type(working_directory) == str:
        working_directory = Path(working_directory)

    if not check_valid_working_directory(working_directory):
        raise ValueError("working directory is not in the right format. The right format is "
                         "`<project_directory>/hash[0:2]/hash[2:4]/hash[4:]`")

    directory_level_1 = working_directory.parent.parent
    directory_level_2 = working_directory.parent

    if not os.path.exists(directory_level_1):
        os.mkdir(directory_level_1)
    if not os.path.exists(directory_level_2):
        os.mkdir(directory_level_2)

    working_directory = directory_level_2.joinpath(input_hash[4:])

    if not os.path.exists(working_directory):
        os.mkdir(working_directory)

    save_path = working_directory.joinpath(f"input.txt")
    if isinstance(additional_iw2d_params, InputFileWakeParams):
        iw2d_input.to_wake_input_file(save_path, additional_iw2d_params)
    else:
        iw2d_input.to_impedance_input_file(save_path, additional_iw2d_params)


def create_element_using_iw2d_legacy(iw2d_input: Union[FlatIW2DInput, RoundIW2DInput], additional_iw2d_params: Union[InputFileFreqParams, InputFileWakeParams],
                                     name: str, beta_x: float, beta_y: float, tag: str = 'IW2D') -> Element:
    """
    Create and return an Element using IW2D object.
    :param iw2d_input: the IW2DInput object
    :param name: the name of the Element
    :param beta_x: the beta function value in the x-plane at the position of the Element
    :param beta_y: the beta function value in the x-plane at the position of the Element
    :param tag: a tag string for the Element
    :return: The newly computed Element
    """
    assert " " not in name, "Spaces are not allowed in element name"

    assert verify_iw2d_config_file(), "The binary and/or project directories specified in config/iw2d_settings.yaml " \
                                      "do not exist or do not contain the required files and directories."

    # the path to the folder containing the IW2D executables
    bin_path = Path(get_iw2d_config_value('binary_directory'))
    # the path to the folder containing the database of already computed elements

    # Check if wake should be calculated
    calculate_wake = isinstance(additional_iw2d_params, InputFileWakeParams)

    # check if the element is already present in the database and create the hash key corresponding to the IW2D input
    already_computed, input_hash, working_directory = check_already_computed(iw2d_input, additional_iw2d_params, name)

    # if an element with the same inputs is not found inside the database, perform the computations and add the results
    # to the database
    if not already_computed:
        add_iw2d_input_to_database(iw2d_input, input_hash, working_directory)
        bin_string = ("wake_" if calculate_wake else "") + \
                     ("round" if isinstance(iw2d_input, RoundIW2DInput) else "flat") + "chamber.x"
        subprocess.run(f'{bin_path.joinpath(bin_string)} < input.txt', shell=True, cwd=working_directory)

    # When the wake is computed with IW2D, a second set of files is provided by IW2D. These correspond to a "converged"
    # simulation with double the number of mesh points for the wake. They files have the _precise suffix to their name.
    # If the wake is computed, we retrieve these file to create the pywit element.
    common_string = "_precise" if calculate_wake else ''

    component_recipes = component_recipes_from_legacy_iw2d_files(directory=working_directory, common_string=common_string)

    return Element(length=iw2d_input.length,
                   beta_x=beta_x, beta_y=beta_y,
                   components=[create_component_from_data(*recipe, relativistic_gamma=iw2d_input.relativistic_gamma)
                               for recipe in component_recipes],
                   name=name, tag=tag, description='A resistive wall element created using IW2D')


def create_element_using_iw2d_python_interface(iw2d_input: Union[FlatIW2DInput, RoundIW2DInput],
                                     frequencies: ArrayLike, name: str,
                                     beta_x: float, beta_y: float, tag: str = 'IW2D') -> Element:
    
    assert " " not in name, "Spaces are not allowed in element name"
    
    frequencies = np.asarray(frequencies)
    
    # Make hash to key database directory
    input_hash = iw2d_input.output_identification_hash(frequencies)
    iw2d_result_directory = Path(get_iw2d_config_value('project_directory')) / input_hash[0:2] / input_hash[2:4] / input_hash[4:]
    
    # If directory does not exist, make it and needed parent directories
    if not iw2d_result_directory.is_dir():
        iw2d_result_directory.mkdir(parents=True)
    
    # See if all files are present
    files_present = [file_name in os.listdir(iw2d_result_directory) for file_name in ["metadata.json", "input_object.pickle", "data.pickle"]]
    if not all(files_present):
        iw2d_result = iw2d_impedance(iw2d_input, frequencies)
        
        iw2d_result.save(iw2d_result_directory)
    else:
        iw2d_result = load_iw2d_result(iw2d_result_directory)
        
    return Element(
        length=iw2d_result.input_object.length,
        beta_x=beta_x, beta_y=beta_y,
        components=[create_component_from_data(*recipe, iw2d_result.input_object.relativistic_gamma)
                    for recipe in component_recipes_from_iw2dresult(iw2d_result)],
        name=name, tag=tag, description='A resistive wall element created using IW2D'
    ) 
   

def verify_iw2d_config_file() -> bool:
    bin_path = Path(get_iw2d_config_value('binary_directory'))
    projects_path = Path(get_iw2d_config_value('project_directory'))
    if not bin_path.exists() or not projects_path.exists():
        return False

    contents = os.listdir(bin_path)
    for filename in ('flatchamber.x', 'roundchamber.x', 'wake_flatchamber.x', 'wake_roundchamber.x'):
        if filename not in contents:
            return False

    return True


def create_multiple_elements_using_iw2d_legacy(iw2d_inputs: Sequence[Union[FlatIW2DInput, RoundIW2DInput]],
                                               additional_iw2d_params: Sequence[Union[InputFileFreqParams, InputFileWakeParams]],
                                               names: Sequence[str], beta_xs: Sequence[float], beta_ys: Sequence[float]) -> List[Element]:
    """
    Create and return a list of Element's using a list of IW2D objects.
    :param iw2d_inputs: the list of IW2DInput objects
    :param names: the list of names of the Element's
    :param beta_xs: the list of beta function values in the x-plane at the position of each Element
    :param beta_ys: the list of beta function values in the x-plane at the position of each Element
    :return: the list of newly computed Element's
    """
    assert len(iw2d_inputs) == len(names) == len(beta_xs) == len(beta_ys), "All input lists need to have the same" \
                                                                           "number of elements"

    for name in names:
        assert " " not in name, "Spaces are not allowed in element name"

    assert verify_iw2d_config_file(), "The binary and/or project directories specified in config/iw2d_settings.yaml " \
                                      "do not exist or do not contain the required files and directories."

    elements = Parallel(n_jobs=-1, prefer='threads')(delayed(create_element_using_iw2d_legacy)(
        iw2d_inputs[i],
        additional_iw2d_params[i],
        names[i],
        beta_xs[i],
        beta_ys[i]
    ) for i in range(len(names)))

    return elements


def create_multiple_elements_using_iw2d_python_interface(iw2d_inputs: Sequence[Union[FlatIW2DInput, RoundIW2DInput]],
                                                  frequencies: Sequence[ArrayLike], names: Sequence[str],
                                                  beta_xs: Sequence[float], beta_ys: Sequence[float]) -> List[Element]:
    
    assert len(iw2d_inputs) == len(names) == len(beta_xs) == len(beta_ys), "All input lists need to have the same" \
                                                                           "number of elements"

    for name in names:
        assert " " not in name, "Spaces are not allowed in element name"

    assert verify_iw2d_config_file(), "The binary and/or project directories specified in config/iw2d_settings.yaml " \
                                      "do not exist or do not contain the required files and directories."

    elements = Parallel(n_jobs=-1, prefer='threads')(delayed(create_element_using_iw2d_python_interface)(
        iw2d_inputs[i],
        frequencies[i],
        names[i],
        beta_xs[i],
        beta_ys[i]
    ) for i in range(len(names)))

    return elements


def create_htcondor_input_file(iw2d_input: Union[FlatIW2DInput, RoundIW2DInput], name: str, directory: Union[str, Path]) -> None:
    exec_string = ""
    if iw2d_input.calculate_wake:
        exec_string += "wake_"
    exec_string += ("round" if isinstance(iw2d_input, RoundIW2DInput) else "flat") + "chamber.x"

    text = f"executable = {exec_string}\n" \
           f"input = {name}_input.txt\n" \
           f"ID = $(Cluster).$(Process)\n" \
           f"output = $(ID).out\n" \
           f"error = $(ID).err\n" \
           f"log = $(Cluster).log\n" \
           f"universe = vanilla\n" \
           f"initialdir = \n" \
           f"when_to_transfer_output = ON_EXIT\n" \
           f'+JobFlavour = "tomorrow"\n' \
           f'queue'

    with open(directory, 'w') as file:
        file.write(text)


def _verify_iw2d_binary_directory(ignore_missing_files: bool = False) -> None:
    bin_path = Path(get_iw2d_config_value('binary_directory'))
    if not ignore_missing_files:
        filenames = ('flatchamber.x', 'roundchamber.x', 'wake_flatchamber.x', 'wake_roundchamber.x')
        assert all(filename in os.listdir(bin_path) for filename in filenames), \
            "In order to utilize IW2D with PyWIT, the four binary files 'flatchamber.x', 'roundchamber.x', " \
            f"'wake_flatchamber.x' and 'wake_roundchamber.x' (as generated by IW2D) must be placed in the directory " \
            f"'{bin_path}'."


def _read_cst_data(filename: Union[str, Path]) -> np.ndarray:
    with open(filename, 'r') as f:
        lines = f.readlines()
    data = []
    for line in lines:
        try:
            data.append([float(e) for e in line.strip().split()])
        except ValueError:
            pass

    return np.asarray(data)


def load_longitudinal_impedance_datafile(path: Union[str, Path]) -> Component:
    data = _read_cst_data(path)
    fs = data[:, 0]
    zs = data[:, 1] + 1j * data[:, 2]
    func = interp1d(x=fs, y=zs, kind='linear', assume_sorted=True, bounds_error=False, fill_value=(0., 0.))
    return Component(impedance=func, plane='z', source_exponents=(0, 0), test_exponents=(0, 0))


def load_transverse_impedance_datafile(path: Union[str, Path]) -> Tuple[Component, Component, Component, Component]:
    data = _read_cst_data(path)
    fs = data[:, 0]
    zs = [data[:, 2 * i + 1] + 1j * data[:, 2 * i + 2] for i in range(4)]
    components = tuple()
    for i, z in enumerate(zs):
        exponents = [int(j == i) for j in range(4)]
        func = interp1d(x=fs, y=z, kind='linear', assume_sorted=True, bounds_error=False, fill_value=(0., 0.))
        components += (Component(impedance=func,
                                 plane='x' if i % 2 == 0 else 'y',
                                 source_exponents=(exponents[0], exponents[1]),
                                 test_exponents=(exponents[2], exponents[3])),)

    return components


def load_longitudinal_wake_datafile(path: Union[str, Path]) -> Component:
    data = _read_cst_data(path)
    ts = data[:, 0]
    ws = data[:, 1] * 1e15
    func = interp1d(x=ts, y=ws, kind='linear', assume_sorted=True, bounds_error=False, fill_value=(0., 0.))
    return Component(wake=func, plane='z', source_exponents=(0, 0), test_exponents=(0, 0))


def load_transverse_wake_datafile(path: Union[str, Path]) -> Tuple[Component, Component, Component, Component]:
    data = _read_cst_data(path)
    ts = data[:, 0]
    ws = [data[:, i] * 1e15 for i in range(1, 5)]
    components = tuple()
    for i, w in enumerate(ws):
        exponents = [int(j == i) for j in range(4)]
        func = interp1d(x=ts, y=w, kind='linear', assume_sorted=True, bounds_error=False, fill_value=(0., 0.))
        components += (Component(wake=func,
                                 plane='x' if i % 2 == 0 else 'y',
                                 source_exponents=(exponents[0], exponents[1]),
                                 test_exponents=(exponents[2], exponents[3])),)

    return components

